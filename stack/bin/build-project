#!/usr/bin/env bash
# usage: build-project <build-dir> <cache-dir> -b <buildpack> -b <buildpack>
set -eo pipefail

usage() {
  cat <<EOF
Usage:
build-project <build-dir> <cache-dir> -b <buildpack> -b <buildpack>
EOF
  return 0
}

options=$(getopt -o h,b: -- "$@")

if [ $? -ne 0 ]; then
    usage
    exit 1
fi

eval set -- "$options"

declare -a buildpacks
while :; do
    case "$1" in
        -h|--help)  usage && exit 1;;
        -b)         buildpacks+=("${2}"); shift 2;;
        *)          shift 1 && break;;
    esac
done

project_root=${1:-/workspace}
cache_root=${2:-/.devstep/cache}
buildpack_root=/.devstep/buildpacks

mkdir -p $project_root
mkdir -p $cache_root
mkdir -p $buildpack_root
mkdir -p /.devstep/.profile.d

function output_redirect() {
	if [[ "$slug_file" == "-" ]]; then
		cat - 1>&2
	else
		cat -
	fi
}

function echo_title() {
  echo $'\e[1G----->' $* | output_redirect
}

function echo_normal() {
  echo $'\e[1G      ' $* | output_redirect
}

function ensure_indent() {
  while read line; do
    if [[ "$line" == --* ]]; then
      echo $'\e[1G'$line | output_redirect
    else
      echo $'\e[1G      ' "$line" | output_redirect
    fi
  done
}

# Centralize cache directories on a single place to simplify
# caching on the host
empty_directory() {
  if [ $(ls -A "${1}" 2>/dev/null | wc -l) = '0' ]; then
    return 0
  else
    return 1
  fi
}
if ! [ -L /var/cache/apt/archives ]; then
  mkdir -p $cache_root/apt
  # Warm up cache with packages available on the container if cache is empty
  if (empty_directory "$cache_root/apt") && ! (empty_directory "/var/cache/apt/archives"); then
    sudo bash -c "shopt -s dotglob && mv /var/cache/apt/archives/* $cache_root/apt"
  fi
  sudo rm -rf /var/cache/apt/archives
  sudo ln -s $cache_root/apt /var/cache/apt/archives
fi

if ! [ -L /var/lib/apt/lists ]; then
  mkdir -p $cache_root/apt-lists
  # Warm up cache with packages available on the container if cache is empty
  if (empty_directory "$cache_root/apt-lists") && ! (empty_directory "/var/lib/apt/lists"); then
    sudo bash -c "shopt -s dotglob && mv /var/lib/apt/lists/* $cache_root/apt-lists"
  fi
  mkdir -p $cache_root/apt-lists/partial
  sudo rm -rf /var/lib/apt/lists
  sudo ln -s $cache_root/apt-lists /var/lib/apt/lists
fi

# In heroku, there are two separate directories, and some
# buildpacks expect that.
# TODO: Figure out if this is needed
# cp -r $project_dir/. $build_root

## Buildpack fixes

export REQUEST_ID=$(openssl rand -base64 32 2>/dev/null)
export APP_DIR="$project_root"
# export HOME="$project_root"

## Fix directory permissions

(cd $project_root && /.devstep/bin/fix-permissions)

## Buildpack detection

declare -a selected_buildpacks
if [[ -z "${buildpacks[@]}" ]]; then
  buildpacks=($buildpack_root/*)
  for buildpack in "${buildpacks[@]}"; do
    if $($buildpack/bin/detect "${project_root}" &>/dev/null); then
      selected_buildpacks+=($buildpack)
    fi
  done
else
  for buildpack in "${buildpacks[@]}"; do
    selected_buildpacks+=(${buildpack_root}/${buildpack})
  done
fi

## Compile!

if [[ -n "$selected_buildpacks[@]" ]]; then
  # TODO: This output is not needed if a single buildpack was detected
  echo_title "Building project at '${project_root}' with the folllowing buildpacks:"
  for bp in "${selected_buildpacks[@]}"; do
    echo "- $bp" | ensure_indent
  done
else
  echo_title "Unable to identify a buildpack for your project!"
  exit 0
fi

for bp in "${selected_buildpacks[@]}"; do
  echo_title "Building with $bp"
  $bp/bin/compile "$project_root" "$cache_root" | ensure_indent
done

echo_title "Build finished successfully!"

## Reload env vars
source $HOME/.bashrc

## Save on disk space if wanted

if [ "${CLEANUP}" = '1' ]; then
  echo_title 'Cleaning up...'

  echo_normal "Running 'rm -rf $cache_root/*'"
  rm -rf $cache_root/*

  echo_normal "Running 'sudo rm -rf tmp/*'"
  sudo rm -rf /tmp/*
fi
