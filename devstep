#!/usr/bin/env bash

set -eu

DEVSTEP_DEBUG=${DEVSTEP_DEBUG:-}
if [ "$DEVSTEP_DEBUG" = '1' ]; then
  export PS4='+ [${BASH_SOURCE##*/}:${LINENO}] '
  set -x
fi

################################################################################
## Set default variables

## Host path for keeping devstep cached packages
DEVSTEP_CACHE_PATH="/tmp/devstep/cache"

## Root path to the project being built
DEVSTEP_WORKSPACE_PATH=`pwd`

## Name of Docker repository to use for the project
DEVSTEP_WORKSPACE_REPO="devstep/$(basename ${DEVSTEP_WORKSPACE_PATH})"

## Starting point for project images
DEVSTEP_SOURCE_IMAGE='fgrehm/devstep:standalone'

## Global options for `docker run`
DEVSTEP_RUN_OPTS=

## `devstep CMD` specific options for `docker run`
DEVSTEP_BUILD_RUN_OPTS=
DEVSTEP_BOOTSTRAP_RUN_OPTS=
DEVSTEP_HACK_RUN_OPTS=
DEVSTEP_REBUILD_RUN_OPTS=

################################################################################
## Load project and user specific configs

## Start with user configs ...
[ -f $HOME/.devsteprc ] && \
  source $HOME/.devsteprc

## ... and override with project configs
[ -f $DEVSTEP_WORKSPACE_PATH/.devsteprc ] && \
  source $DEVSTEP_WORKSPACE_PATH/.devsteprc

################################################################################
## Parse arguments

usage() {
    cat <<EOF
Usage: devstep [OPTIONS] COMMAND

Commands:
  build     - Build a Docker image for current directory sources based on latest successfull build
  pristine  - Rebuild current project associated Docker image from scratch
  bootstrap - Interactively build a base Docker image for the project based on latest successfull build
  hack      - Start a hacking session for the current project using latest version of image and discard the container on exit

Available options:
[ -h | --help ]:     This help message
[ -r | --run-opts ]: Arguments to provide to the 'docker run' command during the build
EOF
    return 0
}

options=$(getopt -o h,r: -l help,run-opts: -- "$@")

if [ $? -ne 0 ]; then
    usage
    exit 1
fi
eval set -- "$options"

while :; do
    case "$1" in
        -h|--help)          usage && exit 1;;
        -r|--run-opts)      DEVSTEP_RUN_OPTS="${DEVSTEP_RUN_OPTS} ${2}"; shift 2;;
        *)                  break;;
    esac
done

# Remove '--' from args
shift 1

# We need a command to run
if [ "$#" != '1' ]; then
  usage && exit 1
fi

################################################################################
## Build options to use on `docker run`

COMMAND="${1}"

# If cache path is still set at this point
if ! [ -z "${DEVSTEP_CACHE_PATH}" ]; then
  DEVSTEP_RUN_OPTS="${DEVSTEP_RUN_OPTS} -v ${DEVSTEP_CACHE_PATH}:/.devstep/cache"
fi

# If by whatever reason this is blank
if [ -z "${DEVSTEP_WORKSPACE_PATH}" ]; then
  echo 'Unknown workspace path!'
  exit 1
fi

DEVSTEP_RUN_OPTS="${DEVSTEP_RUN_OPTS} -v ${DEVSTEP_WORKSPACE_PATH}:/workspace -w /workspace"

if [ "${COMMAND}" = 'pristine' ]; then
  images=$(docker images | grep "^${DEVSTEP_WORKSPACE_REPO}" | awk '{ print $3 }') || true
  if ! [ -z "${images}" ]; then
    containers=$(docker ps -a | grep " ${DEVSTEP_WORKSPACE_REPO}" | awk '{ print $1 }') || true
    echo '==> Removing previously tagged images' 1>&2
    docker rm -f $containers 2>/dev/null || true
    docker rmi -f $images 2>/dev/null || true
    echo
  fi
  # From this point on, the command behaves as the build command
  COMMAND='build'
fi

# if Docker repo exists, we use the latest version as the source image
if $(docker images | grep -q "^${DEVSTEP_WORKSPACE_REPO}"); then
  SOURCE_IMAGE="${DEVSTEP_WORKSPACE_REPO}:latest"
else # otherwise we start from scratch
  SOURCE_IMAGE=${DEVSTEP_SOURCE_IMAGE}
fi

if [ "${COMMAND}" = 'build' ]; then
  DEVSTEP_RUN_OPTS="${DEVSTEP_RUN_OPTS} ${DEVSTEP_BUILD_RUN_OPTS} -d"
  TARGET_IMAGE="${DEVSTEP_WORKSPACE_REPO}:latest"
  RUN_CMD="/.devstep/bin/build-project /workspace"

elif [ "${COMMAND}" = 'bootstrap' ]; then
  DEVSTEP_RUN_OPTS="${DEVSTEP_RUN_OPTS} ${DEVSTEP_BOOTSTRAP_RUN_OPTS} -d -ti --name devstep-bootstrap"
  CID='devstep-bootstrap'
  TARGET_IMAGE="${DEVSTEP_WORKSPACE_REPO}:latest"
  RUN_CMD="bash"

elif [ "${COMMAND}" = 'hack' ]; then
  DEVSTEP_RUN_OPTS="${DEVSTEP_RUN_OPTS} ${DEVSTEP_HACK_RUN_OPTS} -ti --rm"
  RUN_CMD="/.devstep/bin/hack"

else
  echo "Error: Command not found: ${COMMAND}"
  usage && exit 1
fi

################################################################################
## Build / hack on image

function docker_run() {
  echo '==> Starting container with' 1>&2
  echo "    \`- docker run ${DEVSTEP_RUN_OPTS} ${SOURCE_IMAGE} ${RUN_CMD}" 1>&2
  echo 1>&2
  docker run ${DEVSTEP_RUN_OPTS} ${SOURCE_IMAGE} ${RUN_CMD}
  return $?
}

if [ $COMMAND = 'hack' ]; then
  docker_run
  exit $?
elif [ $COMMAND = 'bootstrap' ]; then
  docker_run
  docker attach $CID || {
    echo    '==> The bootstrap process has finished and the container returned'
    echo    '    an exit status != 0'
    echo -n '    Do you want to go ahead and commit this image? [y/N] '
    read answer
    if ! $(echo "${answer}" | grep -qi '^y'); then
      echo 'Aborting'
      docker rm $CID > /dev/null
      exit 1
    fi
  }
elif [ $COMMAND = 'build' ]; then
  CID=$(docker_run)
  docker attach $CID
  test $(docker wait $CID) -eq 0

  echo -e "\n==> Commiting temporary image '${DEVSTEP_WORKSPACE_REPO}:tmp'"
  docker rmi "${DEVSTEP_WORKSPACE_REPO}:tmp" &> /dev/null || true
  docker commit $CID "${DEVSTEP_WORKSPACE_REPO}:tmp"
  docker rm $CID

  echo -e "\n==> Running a 'docker run -d ${DEVSTEP_WORKSPACE_REPO}:tmp bash' to change image's CMD"
  CID=$(docker run -d -w / ${DEVSTEP_WORKSPACE_REPO}:tmp bash)
  docker stop -t=1 $CID
fi

TIMESTAMP=$(date -u +"%Y-%m-%d-%H-%M-%S")
echo -e "\n==> Commiting '${TARGET_IMAGE}' and '${DEVSTEP_WORKSPACE_REPO}:${TIMESTAMP}'"
docker commit $CID "${DEVSTEP_WORKSPACE_REPO}:latest"
docker tag "${DEVSTEP_WORKSPACE_REPO}:latest" "${DEVSTEP_WORKSPACE_REPO}:${TIMESTAMP}"

echo -e "\n==> Removing temporary artifacts used for build"
docker rm $CID
docker rmi "${DEVSTEP_WORKSPACE_REPO}:tmp" &> /dev/null || true
