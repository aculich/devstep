#!/usr/bin/env bash

set -eu

DEVSTEP_DEBUG=${DEVSTEP_DEBUG:-}
if [ "$DEVSTEP_DEBUG" = '1' ]; then
  export PS4='+ [${BASH_SOURCE##*/}:${LINENO}] '
  set -x
fi

################################################################################
## Set default variables

## Host path for keeping devstep cached packages
DEVSTEP_CACHE_PATH="/tmp/devstep/cache"

## Root path to the project being built
DEVSTEP_WORKSPACE_PATH=`pwd`

## Name of the project being worked on
DEVSTEP_WORKSPACE_NAME=$(basename ${DEVSTEP_WORKSPACE_PATH})

## Name of Docker repository to use for the project
DEVSTEP_WORKSPACE_REPO="devstep/${DEVSTEP_WORKSPACE_NAME}"

## Starting point for project images
DEVSTEP_SOURCE_IMAGE='fgrehm/devstep:standalone'

## Global options for `docker run`
DEVSTEP_RUN_OPTS=

## `devstep CMD` specific options for `docker run`
DEVSTEP_BUILD_RUN_OPTS=
DEVSTEP_BOOTSTRAP_RUN_OPTS=
DEVSTEP_HACK_RUN_OPTS=
DEVSTEP_REBUILD_RUN_OPTS=

################################################################################
## Load project and user specific configs

## Start with user configs ...
[ -f $HOME/.devsteprc ] && \
  source $HOME/.devsteprc

## ... and override with project configs
[ -f $DEVSTEP_WORKSPACE_PATH/.devsteprc ] && \
  source $DEVSTEP_WORKSPACE_PATH/.devsteprc

################################################################################
## Parse arguments

usage() {
    cat <<EOF
Usage: devstep [OPTIONS] COMMAND

Commands:
  build     - Build a Docker image for current directory sources based on latest successfull build
  clean     - Remove all images built for the current project
  pristine  - Rebuild current project associated Docker image from scratch
  bootstrap - Interactively build a base Docker image for the project based on latest successfull build
  hack      - Start a hacking session for the current project using latest version of image and discard the container on exit

Available options:
[ -h | --help ]:     This help message
[ -r | --run-opts ]: Arguments to provide to the 'docker run' command during the build
EOF
    return 0
}

options=$(getopt -o h,r: -l help,run-opts: -- "$@")

if [ $? -ne 0 ]; then
    usage
    exit 1
fi
eval set -- "$options"

USER_RUN_OPTS=
while :; do
    case "$1" in
        -h|--help)          usage && exit 1;;
        -r|--run-opts)      USER_RUN_OPTS="${USER_RUN_OPTS} ${2}"; shift 2;;
        *)                  break;;
    esac
done

# Remove '--' from args
shift 1

# We need a command to run
if [ "$#" != '1' ]; then
  usage && exit 1
fi

COMMAND="${1}"

################################################################################
## Handle `pristine` and `clean` commands

function confirm_clean_repo() {
  echo    "==> You are about to remove ${1} image(s) / tag(s) for the '${DEVSTEP_WORKSPACE_REPO}' repository" 1>&2
  echo -n '    Are you sure about that? [y/N] ' 1>&2
  read answer
  if ! $(echo "${answer}" | grep -qi '^y'); then
    echo 'Aborting' 1>&2
    exit 1
  fi
  return 0
}

function clean_repo() {
  images=$(docker images | grep "^${DEVSTEP_WORKSPACE_REPO}" | awk '{ print $3 }') || true
  if ! [ -z "${images}" ]; then
    confirm_clean_repo $(echo $images | wc -w)

    containers=$(docker ps -a | grep " ${DEVSTEP_WORKSPACE_REPO}" | awk '{ print $1 }') || true
    echo '==> Removing previously tagged images and corresponding containers' 1>&2
    docker rm -f $containers 2>/dev/null || true
    docker rmi -f $images 2>/dev/null || true
    echo
  else
    echo "==> No tagged images found for the '${DEVSTEP_WORKSPACE_REPO}' repository" 1>&2
  fi
}

if [ "${COMMAND}" = 'pristine' ] || [ "${COMMAND}" = 'clean' ]; then
  clean_repo
fi

if [ "${COMMAND}" = 'clean' ]; then
  # If we got to this point, there's nothing else we need to do
  exit 0
fi

if [ "${COMMAND}" = 'pristine' ]; then
  # From this point on, the command behaves as the build command
  COMMAND='build'
fi

################################################################################
## Build options to use on `docker run`

# If cache path is still set at this point
if ! [ -z "${DEVSTEP_CACHE_PATH}" ]; then
  DEVSTEP_RUN_OPTS="${DEVSTEP_RUN_OPTS} -v ${DEVSTEP_CACHE_PATH}:/.devstep/cache"
fi

# If by whatever reason this is blank
if [ -z "${DEVSTEP_WORKSPACE_PATH}" ]; then
  echo 'Unknown workspace path!'
  exit 1
fi

DEVSTEP_RUN_OPTS="${DEVSTEP_RUN_OPTS} -v ${DEVSTEP_WORKSPACE_PATH}:/workspace -w /workspace"

# if Docker repo exists, we use the latest version as the source image
if $(docker images | grep -q "^${DEVSTEP_WORKSPACE_REPO}"); then
  SOURCE_IMAGE="${DEVSTEP_WORKSPACE_REPO}:latest"
else # otherwise we start from scratch
  SOURCE_IMAGE=${DEVSTEP_SOURCE_IMAGE}
fi

if [ "${COMMAND}" = 'build' ]; then
  DEVSTEP_RUN_OPTS="${DEVSTEP_RUN_OPTS} -d ${DEVSTEP_BUILD_RUN_OPTS}"
  TARGET_IMAGE="${DEVSTEP_WORKSPACE_REPO}:latest"
  RUN_CMD="/.devstep/bin/build-project /workspace"

elif [ "${COMMAND}" = 'bootstrap' ]; then
  CID='devstep-bootstrap'
  DEVSTEP_RUN_OPTS="${DEVSTEP_RUN_OPTS} -d -ti ${DEVSTEP_BOOTSTRAP_RUN_OPTS} --name ${CID}"
  TARGET_IMAGE="${DEVSTEP_WORKSPACE_REPO}:latest"
  RUN_CMD="bash"

elif [ "${COMMAND}" = 'hack' ]; then
  CID="devhack-${DEVSTEP_WORKSPACE_NAME}"
  DEVSTEP_RUN_OPTS="${DEVSTEP_RUN_OPTS} -ti --rm ${DEVSTEP_HACK_RUN_OPTS} --name ${CID}"
  RUN_CMD="/.devstep/bin/hack"

else
  echo "Error: Command not found: ${COMMAND}"
  usage && exit 1
fi

# Append user provided docker run options at the end so that it has a higher precedence
DEVSTEP_RUN_OPTS="${DEVSTEP_RUN_OPTS} ${USER_RUN_OPTS}"

################################################################################
## Build / hack on image

function docker_run() {
  echo '==> Creating container with' 1>&2
  echo "    \`- docker run ${DEVSTEP_RUN_OPTS} ${SOURCE_IMAGE} ${RUN_CMD}" 1>&2
  echo 1>&2
  docker run ${DEVSTEP_RUN_OPTS} ${SOURCE_IMAGE} ${RUN_CMD}
  return $?
}

if [ $COMMAND = 'hack' ]; then
  # If container already exists and is running, attach
  if $(docker ps | grep -q $CID); then
    echo "==> Attaching to existing ${CID} container"
    docker attach $CID

  # If container exists and is not running, start
  elif $(docker ps -a | grep -q $CID); then
    echo "==> Restarting existing ${CID} container"
    docker start -ai $CID

  # Otherwise just create it
  else
    docker_run
  fi
  exit $?
elif [ $COMMAND = 'bootstrap' ]; then
  docker_run
  docker attach $CID || {
    echo    '==> The bootstrap process has finished and the container returned'
    echo    '    an exit status != 0'
    echo -n '    Do you want to go ahead and commit this image? [y/N] '
    read answer
    if ! $(echo "${answer}" | grep -qi '^y'); then
      echo 'Aborting'
      docker rm $CID > /dev/null
      exit 1
    fi
  }
elif [ $COMMAND = 'build' ]; then
  CID=$(docker_run)
  docker attach $CID
  test $(docker wait $CID) -eq 0

  echo -e "\n==> Commiting temporary image '${DEVSTEP_WORKSPACE_REPO}:tmp'"
  docker rmi "${DEVSTEP_WORKSPACE_REPO}:tmp" &> /dev/null || true
  docker commit $CID "${DEVSTEP_WORKSPACE_REPO}:tmp"
  docker rm $CID

  echo -e "\n==> Running a 'docker run -d ${DEVSTEP_WORKSPACE_REPO}:tmp bash' to change image's CMD"
  CID=$(docker run -d -w / ${DEVSTEP_WORKSPACE_REPO}:tmp bash)
  docker stop -t=1 $CID
fi

TIMESTAMP=$(date -u +"%Y%m%d%H%M%S")
echo -e "\n==> Commiting '${TARGET_IMAGE}' and '${DEVSTEP_WORKSPACE_REPO}:${TIMESTAMP}'"
docker commit $CID "${DEVSTEP_WORKSPACE_REPO}:latest"
docker tag "${DEVSTEP_WORKSPACE_REPO}:latest" "${DEVSTEP_WORKSPACE_REPO}:${TIMESTAMP}"

echo -e "\n==> Removing temporary artifacts used for build"
docker rm $CID
docker rmi "${DEVSTEP_WORKSPACE_REPO}:tmp" &> /dev/null || true
